<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Accessibility Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            background: #0a0a0a;
            color: #fff;
            padding: 10px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            background: #111;
            border: 1px solid #333;
        }

        .stats {
            display: flex;
            gap: 20px;
            font-size: 10px;
        }

        .stat {
            color: #888;
        }

        .stat span {
            color: #0ff;
            font-weight: bold;
        }

        .toggles {
            display: flex;
            gap: 5px;
        }

        .toggle {
            padding: 4px 10px;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #888;
            cursor: pointer;
            font-size: 10px;
        }

        .toggle.active {
            background: #0ff;
            color: #000;
            border-color: #0ff;
        }

        .section-title {
            color: #0ff;
            font-size: 12px;
            margin: 15px 0 8px 0;
            padding: 4px 8px;
            background: #111;
            border-left: 3px solid #0ff;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .section-help {
            font-size: 9px;
            color: #888;
            font-weight: normal;
        }

        /* Heatmap Grid */
        .heatmap-container {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .heatmap-panel {
            flex: 1;
            background: #111;
            border: 1px solid #333;
            padding: 10px;
        }

        .heatmap-grid {
            display: grid;
            gap: 1px;
            background: #222;
            border: 1px solid #333;
        }

        .heatmap-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: bold;
            position: relative;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .heatmap-cell:hover {
            transform: scale(1.1);
            z-index: 10;
            border: 2px solid #0ff;
        }

        .heatmap-cell.highlighted {
            border: 2px solid #fff;
            z-index: 5;
        }

        .heatmap-label {
            background: #111;
            padding: 2px 4px;
            font-size: 8px;
            text-align: center;
        }

        /* Color Recommender */
        .recommender-panel {
            background: #111;
            border: 1px solid #333;
            padding: 10px;
            margin-bottom: 20px;
        }

        .recommender-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .control-group label {
            font-size: 9px;
            color: #888;
        }

        .control-group input {
            background: #1a1a1a;
            border: 1px solid #333;
            color: #0ff;
            padding: 4px 8px;
            font-size: 10px;
            font-family: inherit;
            width: 60px;
        }

        .btn {
            padding: 4px 12px;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #0ff;
            cursor: pointer;
            font-size: 10px;
            font-family: inherit;
        }

        .btn:hover {
            background: #0ff;
            color: #000;
        }

        .btn.primary {
            background: #0ff;
            color: #000;
        }

        .recommendations-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .recommendation-card {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .recommendation-card:hover {
            border-color: #0ff;
            transform: translateY(-2px);
        }

        .recommendation-card.selected {
            border: 2px solid #0ff;
            background: #1a3a3a;
        }

        .rec-color-preview {
            width: 100%;
            height: 40px;
            margin-bottom: 5px;
            border: 1px solid #333;
            position: relative;
        }

        .rec-score {
            font-size: 9px;
            color: #888;
            display: flex;
            justify-content: space-between;
            margin-top: 3px;
        }

        .rec-score-value {
            color: #0ff;
            font-weight: bold;
        }

        .preview-dots {
            position: absolute;
            bottom: 2px;
            right: 2px;
            display: flex;
            gap: 2px;
        }

        .preview-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 1px solid #000;
        }

        /* Color Spectrum */
        .spectrum-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .spectrum-panel {
            background: #111;
            border: 1px solid #333;
            padding: 10px;
        }

        .panel-title {
            font-size: 10px;
            color: #888;
            margin-bottom: 8px;
            text-align: center;
        }

        .spectrum-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 2px;
        }

        .spectrum-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: bold;
            border: 1px solid #000;
            cursor: pointer;
            position: relative;
        }

        .spectrum-cell:hover {
            z-index: 10;
            transform: scale(1.2);
            border: 2px solid #0ff;
        }

        /* Color Space Map */
        .colorspace-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .colorspace-panel {
            background: #111;
            border: 1px solid #333;
            padding: 10px;
        }

        .colorspace-canvas {
            width: 100%;
            height: auto;
            aspect-ratio: 3/2;
            background: #000;
            border: 1px solid #333;
            cursor: crosshair;
        }

        .info-text {
            font-size: 9px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>

<body>
    <div class="header">
        <div class="stats">
            <div class="stat">Deuteranopia: <span>5.0%</span></div>
            <div class="stat">Protanopia: <span>1.0%</span></div>
            <div class="stat">Tritanopia: <span>0.01%</span></div>
            <div class="stat">Total: <span>~8%</span> (~300M people)</div>
        </div>
        <div class="toggles">
            <button class="toggle active" data-mode="normal">Normal</button>
            <button class="toggle" data-mode="deuteranopia">Deuteranopia</button>
            <button class="toggle" data-mode="protanopia">Protanopia</button>
            <button class="toggle" data-mode="tritanopia">Tritanopia</button>
        </div>
    </div>

    <div class="section-title">‚ñ† Color Spectrum Views - Original vs Colorblind Simulation</div>
    <div class="spectrum-container" id="spectrumContainer"></div>

    <div class="section-title">
        <span>‚ñ† Color Difference Heatmap (ŒîE) - Perceptual Distance Matrix</span>
        <span class="section-help">Hover to link halves | Top Right: Visual | Bottom Left: Numeric</span>
    </div>
    <div class="heatmap-container" id="heatmapContainer"></div>

    <div class="section-title">
        <span>‚ö° Intelligent Color Recommender - Deterministic Greedy Algorithm</span>
        <span class="section-help">Picks the mathematically optimal next color | Non-randomized</span>
    </div>

    <div class="recommender-panel">
        <!-- Algorithm Explanation -->
        <div style="background: #0a0a0a; border: 1px solid #0ff; padding: 10px; margin-bottom: 10px; font-size: 10px;">
            <div style="color: #0ff; font-weight: bold; margin-bottom: 6px;">üéÆ Two Modes:</div>
            <div style="color: #aaa; line-height: 1.6;">
                <strong style="color:#fff">‚èπ Planning Mode (Stop Game - Default):</strong><br>
                <span style="margin-left: 20px;">‚Ä¢ Uses <strong style="color:#0f0">Global Optimization</strong> - finds all colors simultaneously</span><br>
                <span style="margin-left: 20px;">‚Ä¢ Maximizes minimum pairwise distance across entire palette</span><br>
                <span style="margin-left: 20px;">‚Ä¢ Adjust "Team Colors" slider to explore different palette sizes</span><br>
                <span style="margin-left: 20px;">‚Ä¢ Shows what optimal complete palette would look like</span><br>
                <span style="margin-left: 20px;">‚Ä¢ First 6 colors always included + globally optimized additions</span><br>
                <br>
                <strong style="color:#fff">‚ñ∂ Game Mode (Start Game):</strong><br>
                <span style="margin-left: 20px;">‚Ä¢ Uses <strong style="color:#ff0">Iterative Greedy</strong> - adds one color at a time</span><br>
                <span style="margin-left: 20px;">‚Ä¢ Each new color maximizes distance from current palette</span><br>
                <span style="margin-left: 20px;">‚Ä¢ Click <strong style="color:#0ff">"+ Add Team Color"</strong> to add the #1 optimal next color</span><br>
                <span style="margin-left: 20px;">‚Ä¢ Build your palette step-by-step with guaranteed optimal choices</span><br>
                <span style="margin-left: 20px;">‚Ä¢ Team Colors slider locked during game</span><br>
                <br>
                <strong style="color:#fff">üìä Transparent Calculation Formula:</strong><br>
                <div style="margin-left: 20px; font-family: monospace; background: #111; padding: 8px; margin-top: 6px; border-left: 2px solid #0ff;">
                    <div style="color:#0ff;">Score = Œ£(mode_weights √ó min_distances) - Œ£(UI_penalties) + TNIL_bonus</div>
                    <div style="color:#888; font-size: 9px; margin-top: 4px;">
                        ‚Ä¢ mode_weights: [Normal: w_n%, Deut: w_d%, Prot: w_p%, Trit: w_t%]<br>
                        ‚Ä¢ min_distances: min(ŒîE to each existing color in each mode)<br>
                        ‚Ä¢ UI_penalties: Œ£((threshold - ŒîE) √ó 100) for each UI/problematic color<br>
                        ‚Ä¢ TNIL_bonus: +bonus if name unique, 0 if duplicate (filtered out)<br>
                        ‚Ä¢ If min_distance < minŒîE: penalty = (minŒîE - distance) √ó 2 √ó weight
                    </div>
                </div>
                <span style="margin-left: 20px; margin-top: 6px; display: block;">‚Ä¢ Hover over candidates to see detailed score breakdown with actual values</span><br>
                <br>
                <span style="color:#0ff;">‚úì 100% Deterministic: Same inputs always produce same results (no randomness)</span>
            </div>
        </div>

        <!-- Calculation Breakdown Tooltip -->
        <div id="calculationBreakdown" style="
            position: fixed;
            background: #0a0a0a;
            border: 1px solid #f80;
            padding: 10px;
            display: none;
            z-index: 1000;
            max-width: 500px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            font-size: 9px;
        ">
            <div style="font-size: 10px; color: #f80; font-weight: bold; margin-bottom: 6px;">
                üî¨ Score Breakdown
            </div>
            <div id="breakdownContent" style="font-family: monospace; line-height: 1.5;"></div>
        </div>
        <div class="recommender-controls">
            <div class="control-group">
                <button class="btn primary" id="startGameBtn" style="font-size: 11px; padding: 6px 16px;">‚ñ∂ Start Game</button>
                <button class="btn" id="stopGameBtn" style="font-size: 11px; padding: 6px 16px; display: none;">‚èπ Stop Game</button>
                <button class="btn" id="resetGameBtn" style="font-size: 11px; padding: 6px 16px;">‚Üª Reset Optimal</button>
            </div>
            <div class="control-group">
                <label>Team Colors:</label>
                <input type="range" id="teamSize" value="8" min="3" max="32" style="width: 100px">
                <span id="teamSizeVal" style="font-size:11px; color:#0ff; font-weight:bold">8</span>
            </div>
            <div class="control-group">
                <button class="btn" id="addTeamColorBtn" style="font-size: 10px; padding: 4px 12px;" disabled>+ Add Team Color</button>
            </div>
            <div class="control-group" style="margin-left: auto;">
                <input type="checkbox" id="showGamut" checked>
                <label for="showGamut">Show Gradient</label>
            </div>
            <div class="control-group">
                <label>Min ŒîE:</label>
                <input type="number" id="minDelta" value="30" min="10" max="100" style="width: 50px">
            </div>
        </div>
        
        <!-- Preset Selection -->
        <div class="recommender-controls" style="border-top: 1px solid #333; padding-top: 8px; margin-top: 8px;">
            <div class="control-group">
                <label style="color:#fff">Preset Mode:</label>
            </div>
            <div class="control-group">
                <button class="btn primary" id="presetGameTeams" style="font-size: 10px; padding: 4px 12px;">Game Teams</button>
                <button class="btn" id="presetPureColor" style="font-size: 10px; padding: 4px 12px;">Pure Color</button>
            </div>
        </div>

        <!-- Student Manager (Game Teams Mode) -->
        <div id="studentManagerGameTeams" class="recommender-controls" style="border-top: 1px solid #333; padding-top: 8px; margin-top: 8px;">
            <div class="control-group">
                <label style="color:#fff">Student Manager (Live Update):</label>
            </div>
            <div class="control-group">
                <label>Normal:</label>
                <input type="number" id="studentNormal" value="92" min="0" max="100" style="width: 50px">
            </div>
            <div class="control-group">
                <label>Deut:</label>
                <input type="number" id="studentDeut" value="5" min="0" max="100" style="width: 50px">
            </div>
            <div class="control-group">
                <label>Prot:</label>
                <input type="number" id="studentProt" value="1" min="0" max="100" style="width: 50px">
            </div>
            <div class="control-group">
                <label>Trit:</label>
                <input type="number" id="studentTrit" value="0.01" step="0.01" min="0" max="100" style="width: 50px">
            </div>
        </div>

        <!-- Pure Color Mode -->
        <div id="pureColorMode" class="recommender-controls" style="border-top: 1px solid #333; padding-top: 8px; margin-top: 8px; display: none;">
            <div class="control-group">
                <label style="color:#fff">Select Colorblind Status:</label>
            </div>
            <div class="control-group">
                <button class="btn" id="pureNormal" style="font-size: 10px; padding: 4px 12px;">Normal</button>
                <button class="btn" id="pureDeuteranopia" style="font-size: 10px; padding: 4px 12px;">Deuteranopia</button>
                <button class="btn" id="pureProtanopia" style="font-size: 10px; padding: 4px 12px;">Protanopia</button>
                <button class="btn" id="pureTritanopia" style="font-size: 10px; padding: 4px 12px;">Tritanopia</button>
            </div>
        </div>

        <!-- Pure Color Preview -->
        <div id="pureColorPreview" style="display: none; margin-top: 10px; padding: 10px; background: #0a0a0a; border: 1px solid #0ff;">
            <div style="color: #0ff; font-weight: bold; margin-bottom: 8px;">Pure Color Preview</div>
            <div id="pureColorGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;"></div>
        </div>

        <!-- UI Constraints -->
        <div class="recommender-controls" style="border-top: 1px solid #333; padding-top: 8px; margin-top: 8px;">
            <div class="control-group">
                <label style="color:#fff">Avoid UI Colors:</label>
            </div>
            <div class="control-group">
                <input type="checkbox" id="avoidBlack" checked> <label>Black</label>
            </div>
            <div class="control-group">
                <input type="checkbox" id="avoidWhite" checked> <label>White</label>
            </div>
            <div class="control-group">
                <input type="checkbox" id="avoidGrey" checked> <label>Grey</label>
            </div>
            <div class="control-group">
                <label>Min Dist:</label>
                <input type="number" id="uiMinDist" value="40" min="10" max="100" style="width: 50px">
            </div>
        </div>

        <!-- Problematic Color Avoidance -->
        <div class="recommender-controls" style="border-top: 1px solid #333; padding-top: 8px; margin-top: 8px;">
            <div class="control-group">
                <label style="color:#f88">Avoid Problematic Colors:</label>
            </div>
            <div class="control-group">
                <input type="checkbox" id="avoidBlood" checked> <label>Blood (Dark Red)</label>
            </div>
            <div class="control-group">
                <input type="checkbox" id="avoidBrown" checked> <label>Brown/Bodily Fluids</label>
            </div>
            <div class="control-group">
                <label>Min Dist:</label>
                <input type="number" id="problematicMinDist" value="25" min="10" max="100" style="width: 50px">
            </div>
        </div>

        <!-- TNIL Name Uniqueness Bias -->
        <div class="recommender-controls" style="border-top: 1px solid #333; padding-top: 8px; margin-top: 8px;">
            <div class="control-group">
                <label style="color:#0ff">TNIL Name Uniqueness Bias:</label>
            </div>
            <div class="control-group">
                <label>Bonus for unique names:</label>
                <input type="number" id="tnilUniquenessBonus" value="100" min="0" max="500" style="width: 50px">
                <span style="font-size:9px;color:#666;margin-left:5px">%</span>
            </div>
        </div>

        <!-- Hue Shift Bias -->
        <div class="recommender-controls" style="border-top: 1px solid #333; padding-top: 8px; margin-top: 8px;">
            <div class="control-group">
                <label style="color:#0ff">Hue Shift Bias:</label>
            </div>
            <div class="control-group">
                <label>Hue preference:</label>
                <input type="number" id="hueShiftBias" value="0" min="-180" max="180" style="width: 50px">
                <span style="font-size:9px;color:#666;margin-left:5px">degrees</span>
            </div>
            <div class="control-group">
                <label>Strength:</label>
                <input type="number" id="hueShiftStrength" value="0" min="0" max="100" style="width: 50px">
                <span style="font-size:9px;color:#666;margin-left:5px">%</span>
            </div>
        </div>

        <div class="recommendations-grid" id="recommendationsGrid"></div>
    </div>

    <div class="section-title">‚óÜ Color Space Mapping - a* vs b* (CIELAB)</div>
    <div class="colorspace-container" id="colorspaceContainer"></div>

    <script>
        // TNIL Color Naming System (must be defined first)
        const colorRoots = ["gy", "≈àr", "ml", "ƒçw", "·∏ër", "lw", "≈æl", "vm"];
        const stems = ["a", "e", "u"];
        const grayscale = ["axm-", "ucv-", "acv-", "ecv-", "abv-"];

        const colorStems = colorRoots.map(
            (root) => stems.map(
                (stem) => stem + root + "-"
            )).reduce((curr, acc) => [...curr, ...acc], []);

        // Full color names mapping
        const tnilFullNames = {
            "agy-": "Agy", "egy-": "Egy", "ugy-": "Ugy",
            "a≈ôr-": "A≈ôr", "e≈ôr-": "E≈ôr", "u≈ôr-": "U≈ôr",
            "aml-": "Aml", "eml-": "Eml", "uml-": "Uml",
            "aƒçw-": "Aƒçw", "eƒçw-": "Eƒçw", "uƒçw-": "Uƒçw",
            "a·∏ër-": "A·∏ër", "e·∏ër-": "E·∏ër", "u·∏ër-": "U·∏ër",
            "alw-": "Alw", "elw-": "Elw", "ulw-": "Ulw",
            "a≈æl-": "A≈æl", "e≈æl-": "E≈æl", "u≈æl-": "U≈æl",
            "avm-": "Avm", "evm-": "Evm", "uvm-": "Uvm",
            "axm-": "Axm", "ucv-": "Ucv", "acv-": "Acv", "ecv-": "Ecv", "abv-": "Abv"
        };

        function rgbToHSL(rgb) {
            const [r, g, b] = rgb.map(v => v / 255);
            const min = Math.min(r, g, b);
            const max = Math.max(r, g, b);
            let l = (min + max) / 2;
            let s, h;

            if (max - min < 0.05) {
                s = 0;
                h = 0;
            } else {
                s = l < 0.5 ? (max - min) / (max + min)
                    : (max - min) / (2.0 - max - min);
                if (r === max) {
                    h = 0.0 + (g - b) / (max - min);
                } else if (g === max) {
                    h = 2.0 + (b - r) / (max - min);
                } else {
                    h = 4.0 + (r - g) / (max - min);
                }
            }
            return {
                h: (h <= 0) * 360 + 60 * h,
                s: s,
                l: l
            };
        }

        function hueToRoot(num) {
            return colorStems[(Math.ceil(num / 15) + 1) % 24];
        }

        function rgbToTNIL(rgb, fullName = false) {
            const hsl = rgbToHSL(rgb);
            let tnilCode;
            if (hsl.s < 0.2) {
                tnilCode = grayscale[Math.floor(4.999 * hsl.l)];
            } else {
                tnilCode = hueToRoot(hsl.h);
            }
            
            if (fullName) {
                return tnilFullNames[tnilCode] || tnilCode.replace('-', '');
            }
            return tnilCode;
        }

        // Initial Palette - first 6 colors keep their original names
        let colors = [
            { name: 'Cyan', hex: '#00FFFF', rgb: [0, 255, 255] },
            { name: 'Magenta', hex: '#FF00FF', rgb: [255, 0, 255] },
            { name: 'Lime', hex: '#00FF00', rgb: [0, 255, 0] },
            { name: 'Gold', hex: '#FFD700', rgb: [255, 215, 0] },
            { name: 'Blue', hex: '#0000FF', rgb: [0, 0, 255] },
            { name: 'Red', hex: '#FF0000', rgb: [255, 0, 0] }
        ];

        // State
        let defaultPlan = [];
        let hoveredCandidate = null;
        let pinnedCandidate = null;
        let gameMode = false; // false = planning mode (global opt), true = game mode (iterative)
        let presetMode = 'gameTeams'; // 'gameTeams' or 'pureColor'
        let pureColorStatus = 'normal'; // For pure color mode

        let currentMode = 'normal';

        const CB_MATRICES = {
            deuteranopia: [[0.625, 0.375, 0], [0.7, 0.3, 0], [0, 0.3, 0.7]],
            protanopia: [[0.567, 0.433, 0], [0.558, 0.442, 0], [0, 0.242, 0.758]],
            tritanopia: [[0.95, 0.05, 0], [0, 0.433, 0.567], [0, 0.475, 0.525]]
        };

        function simulateColorBlindness(rgb, type) {
            if (type === 'normal') return rgb;
            const matrix = CB_MATRICES[type];
            return [
                Math.round(matrix[0][0] * rgb[0] + matrix[0][1] * rgb[1] + matrix[0][2] * rgb[2]),
                Math.round(matrix[1][0] * rgb[0] + matrix[1][1] * rgb[1] + matrix[1][2] * rgb[2]),
                Math.round(matrix[2][0] * rgb[0] + matrix[2][1] * rgb[1] + matrix[2][2] * rgb[2])
            ];
        }

        function rgbToLab(rgb) {
            let [r, g, b] = rgb.map(v => {
                v /= 255;
                return v > 0.04045 ? Math.pow((v + 0.055) / 1.055, 2.4) : v / 12.92;
            });
            let x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;
            let y = (r * 0.2126 + g * 0.7152 + b * 0.0722);
            let z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;
            const f = t => t > 0.008856 ? Math.pow(t, 1 / 3) : (7.787 * t) + 16 / 116;
            [x, y, z] = [f(x), f(y), f(z)];
            return [(116 * y) - 16, 500 * (x - y), 200 * (y - z)];
        }

        function labToRgb(lab) {
            let y = (lab[0] + 16) / 116;
            let x = lab[1] / 500 + y;
            let z = y - lab[2] / 200;
            const fInv = (t) => t > 0.206893034 ? t * t * t : (t - 16 / 116) / 7.787;
            x = 0.95047 * fInv(x);
            y = 1.00000 * fInv(y);
            z = 1.08883 * fInv(z);
            let r = x * 3.2406 + y * -1.5372 + z * -0.4986;
            let g = x * -0.9689 + y * 1.8758 + z * 0.0415;
            let b = x * 0.0557 + y * -0.2040 + z * 1.0570;
            const gamma = (v) => v > 0.0031308 ? 1.055 * Math.pow(v, 1 / 2.4) - 0.055 : 12.92 * v;
            return [
                Math.round(gamma(r) * 255),
                Math.round(gamma(g) * 255),
                Math.round(gamma(b) * 255)
            ];
        }

        function isRgbInGamut(rgb) {
            return rgb[0] >= 0 && rgb[0] <= 255 &&
                rgb[1] >= 0 && rgb[1] <= 255 &&
                rgb[2] >= 0 && rgb[2] <= 255;
        }

        function deltaE(lab1, lab2) {
            return Math.sqrt(Math.pow(lab1[0] - lab2[0], 2) + Math.pow(lab1[1] - lab2[1], 2) + Math.pow(lab1[2] - lab2[2], 2));
        }

        function getTextColor(rgb) {
            return (0.299 * rgb[0] + 0.587 * rgb[1] + 0.114 * rgb[2]) > 128 ? '#000' : '#fff';
        }

        function rgbToHex(rgb) {
            return '#' + rgb.map(v => Math.max(0, Math.min(255, Math.round(v))).toString(16).padStart(2, '0')).join('');
        }

        // --- Core Logic ---

        function getWeights() {
            // Use student manager values (which sync with weight inputs)
            return {
                normal: (parseFloat(document.getElementById('studentNormal').value) || 92) / 100,
                deuteranopia: (parseFloat(document.getElementById('studentDeut').value) || 5) / 100,
                protanopia: (parseFloat(document.getElementById('studentProt').value) || 1) / 100,
                tritanopia: (parseFloat(document.getElementById('studentTrit').value) || 0.01) / 100
            };
        }

        function getUIConstraints() {
            const constraints = [];
            const minDist = parseFloat(document.getElementById('uiMinDist').value) || 40;
            if (document.getElementById('avoidBlack').checked) constraints.push({ rgb: [0, 0, 0], name: 'Black' });
            if (document.getElementById('avoidWhite').checked) constraints.push({ rgb: [255, 255, 255], name: 'White' });
            if (document.getElementById('avoidGrey').checked) constraints.push({ rgb: [128, 128, 128], name: 'Grey' });
            
            // Problematic colors with their own distance threshold
            const problematicMinDist = parseFloat(document.getElementById('problematicMinDist').value) || 30;
            if (document.getElementById('avoidBlood').checked) {
                // Dark red / blood colors - key problematic shades
                constraints.push({ rgb: [139, 0, 0], name: 'Dark Red', minDist: problematicMinDist });
                constraints.push({ rgb: [128, 0, 0], name: 'Maroon', minDist: problematicMinDist });
                constraints.push({ rgb: [165, 42, 42], name: 'Brown Red', minDist: problematicMinDist });
            }
            if (document.getElementById('avoidBrown').checked) {
                // Brown / bodily fluid colors
                constraints.push({ rgb: [101, 67, 33], name: 'Brown', minDist: problematicMinDist });
                constraints.push({ rgb: [139, 69, 19], name: 'Saddle Brown', minDist: problematicMinDist });
                constraints.push({ rgb: [160, 82, 45], name: 'Sienna', minDist: problematicMinDist });
            }
            
            return { colors: constraints, minDist: minDist };
        }

        function calculateDetailedScore(rgb, existingColors, returnBreakdown = false) {
            const weights = getWeights();
            const uiConstraints = getUIConstraints();
            const minDelta = parseFloat(document.getElementById('minDelta').value) || 20;
            const tnilBonus = parseFloat(document.getElementById('tnilUniquenessBonus').value) || 100;
            const hueShiftBias = parseFloat(document.getElementById('hueShiftBias').value) || 0;
            const hueShiftStrength = parseFloat(document.getElementById('hueShiftStrength').value) || 0;
            
            let totalScore = 0;
            const lab = rgbToLab(rgb);
            const tnilName = rgbToTNIL(rgb);
            const breakdown = {
                rgb: rgb,
                hex: rgbToHex(rgb),
                lab: lab,
                tnilName: tnilName,
                uiPenalties: [],
                modeScores: [],
                tnilBonus: 0,
                total: 0
            };
            
            // Avoid UI colors and problematic colors
            for (let ui of uiConstraints.colors) {
                const uiLab = rgbToLab(ui.rgb);
                const dist = deltaE(lab, uiLab);
                const threshold = ui.minDist || uiConstraints.minDist;
                if (dist < threshold) {
                    const penalty = (threshold - dist) * 100;
                    totalScore -= penalty;
                    breakdown.uiPenalties.push({
                        name: ui.name,
                        distance: dist,
                        penalty: penalty
                    });
                }
            }

            // Calculate weighted colorblind distances
            const modes = ['normal', 'deuteranopia', 'protanopia', 'tritanopia'];
            modes.forEach(mode => {
                const w = weights[mode];
                if (w <= 0) return;
                
                const simRgb = simulateColorBlindness(rgb, mode);
                const simLab = rgbToLab(simRgb);
                let minDistInMode = Infinity;
                let closestColor = null;
                
                existingColors.forEach(color => {
                    const existingSimRgb = simulateColorBlindness(color.rgb, mode);
                    const existingSimLab = rgbToLab(existingSimRgb);
                    const dist = deltaE(simLab, existingSimLab);
                    if (dist < minDistInMode) {
                        minDistInMode = dist;
                        closestColor = color.name;
                    }
                });
                
                let modeScore = minDistInMode * w;
                let penalty = 0;
                if (minDistInMode < minDelta) {
                    penalty = (minDelta - minDistInMode) * 2 * w;
                    modeScore -= penalty;
                }
                totalScore += modeScore;
                
                breakdown.modeScores.push({
                    mode: mode,
                    weight: w,
                    minDistance: minDistInMode,
                    closestColor: closestColor,
                    baseScore: minDistInMode * w,
                    penalty: penalty,
                    finalScore: modeScore
                });
            });
            
            // Hue shift bias
            if (hueShiftStrength > 0) {
                const hsl = rgbToHSL(rgb);
                const hueDiff = Math.abs(hsl.h - hueShiftBias);
                const normalizedDiff = Math.min(hueDiff, 360 - hueDiff); // Circular distance
                const hueScore = (180 - normalizedDiff) * (hueShiftStrength / 100);
                totalScore += hueScore;
                breakdown.hueShiftScore = hueScore;
            }
            
            // TNIL name proportional distribution bonus
            // Count how many times each TNIL name appears
            const existingTnilNames = existingColors.map(c => c.name || rgbToTNIL(c.rgb));
            const tnilCounts = {};
            existingTnilNames.forEach(name => {
                tnilCounts[name] = (tnilCounts[name] || 0) + 1;
            });
            
            const currentCount = tnilCounts[tnilName] || 0;
            const totalColors = existingColors.length;
            
            // Calculate bonus inversely proportional to frequency
            // Names that appear 0 times get full bonus
            // Names that appear more get progressively less bonus
            if (totalColors > 0) {
                const frequency = currentCount / totalColors;
                const proportionalBonus = tnilBonus * (1 - frequency);
                totalScore += proportionalBonus;
                breakdown.tnilBonus = proportionalBonus;
                breakdown.tnilFrequency = frequency;
                breakdown.tnilCount = currentCount;
            } else {
                totalScore += tnilBonus;
                breakdown.tnilBonus = tnilBonus;
            }
            
            breakdown.total = totalScore;
            return returnBreakdown ? breakdown : totalScore;
        }

        // --- Intelligent Geometric Optimization ---

        function findOptimalColorGeometric(existingColors) {
            console.log(`findOptimalColorGeometric called with ${existingColors.length} existing colors`);
            const weights = getWeights();
            const uiConstraints = getUIConstraints();
            const minDelta = parseFloat(document.getElementById('minDelta').value) || 20;
            
            console.log('Weights:', weights);
            console.log('UI Constraints:', uiConstraints);
            console.log('Min Delta:', minDelta);
            
            // Sample the gamut space intelligently
            const samples = [];
            const step = 12; // Finer grid for better coverage
            
            for (let L = 25; L <= 85; L += step) {
                for (let a = -100; a <= 100; a += step) {
                    for (let b = -100; b <= 100; b += step) {
                        const rgb = labToRgb([L, a, b]);
                        if (isRgbInGamut(rgb)) {
                            samples.push({ rgb, lab: [L, a, b] });
                        }
                    }
                }
            }
            
            console.log(`Generated ${samples.length} samples to evaluate`);
            
            // Score each sample using weighted colorblind distances
            let bestSample = null;
            let bestScore = -Infinity;
            let validSamples = 0;
            
            for (let sample of samples) {
                // First check: ensure minimum distance to ALL existing colors
                let tooClose = false;
                let minDistToExisting = Infinity;
                for (let existing of existingColors) {
                    const dist = deltaE(sample.lab, rgbToLab(existing.rgb));
                    minDistToExisting = Math.min(minDistToExisting, dist);
                    if (dist < minDelta * 0.8) { // Enforce 80% of minDelta as hard constraint
                        tooClose = true;
                        break;
                    }
                }
                if (tooClose) continue;
                
                let score = 0;
                
                // Check UI constraints and problematic colors
                for (let ui of uiConstraints.colors) {
                    const dist = deltaE(sample.lab, rgbToLab(ui.rgb));
                    const threshold = ui.minDist || uiConstraints.minDist;
                    if (dist < threshold) {
                        score -= (threshold - dist) * 200; // Stronger penalty
                    }
                }
                
                // Calculate weighted minimum distances across colorblind modes
                const modes = ['normal', 'deuteranopia', 'protanopia', 'tritanopia'];
                let totalWeightedDist = 0;
                
                for (let mode of modes) {
                    const w = weights[mode];
                    if (w <= 0) continue;
                    
                    const simRgb = simulateColorBlindness(sample.rgb, mode);
                    const simLab = rgbToLab(simRgb);
                    let minDist = Infinity;
                    
                    for (let existing of existingColors) {
                        const existingSimRgb = simulateColorBlindness(existing.rgb, mode);
                        const existingSimLab = rgbToLab(existingSimRgb);
                        const dist = deltaE(simLab, existingSimLab);
                        minDist = Math.min(minDist, dist);
                    }
                    
                    // Reward distance, heavily penalize being too close
                    let modeScore = minDist * w;
                    if (minDist < minDelta) {
                        modeScore -= (minDelta - minDist) * 5 * w; // Much stronger penalty
                    }
                    totalWeightedDist += modeScore;
                }
                
                score += totalWeightedDist;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestSample = sample;
                }
                validSamples++;
            }
            
            console.log(`Evaluated ${validSamples} valid samples (passed distance check) out of ${samples.length} total`);
            if (bestSample) {
                console.log(`Best sample: ${rgbToHex(bestSample.rgb)} LAB(${bestSample.lab[0].toFixed(1)}, ${bestSample.lab[1].toFixed(1)}, ${bestSample.lab[2].toFixed(1)}) with score ${bestScore.toFixed(2)}`);
                
                // Show distances to existing colors
                console.log('Distances to existing colors:');
                existingColors.forEach((c, i) => {
                    const dist = deltaE(bestSample.lab, rgbToLab(c.rgb));
                    console.log(`  ${i + 1}. ${c.name}: ŒîE = ${dist.toFixed(1)}`);
                });
            } else {
                console.warn('NO VALID SAMPLE FOUND!');
            }
            
            return bestSample;
        }

        function findOptimalColorRefined(coarseSample, existingColors, iterations = 50) {
            const weights = getWeights();
            const minDelta = parseFloat(document.getElementById('minDelta').value) || 20;
            
            let currentLab = [...coarseSample.lab];
            let currentScore = calculateDetailedScore(labToRgb(currentLab), existingColors);
            
            // Gradient ascent with adaptive step size
            let stepSize = 5;
            
            for (let iter = 0; iter < iterations; iter++) {
                let improved = false;
                
                // Try small perturbations in each LAB dimension
                for (let dim = 0; dim < 3; dim++) {
                    for (let direction of [-1, 1]) {
                        const testLab = [...currentLab];
                        testLab[dim] += direction * stepSize;
                        
                        // Clamp to reasonable LAB ranges
                        testLab[0] = Math.max(0, Math.min(100, testLab[0]));
                        testLab[1] = Math.max(-128, Math.min(127, testLab[1]));
                        testLab[2] = Math.max(-128, Math.min(127, testLab[2]));
                        
                        const testRgb = labToRgb(testLab);
                        if (!isRgbInGamut(testRgb)) continue;
                        
                        const testScore = calculateDetailedScore(testRgb, existingColors);
                        
                        if (testScore > currentScore) {
                            currentLab = testLab;
                            currentScore = testScore;
                            improved = true;
                            break;
                        }
                    }
                    if (improved) break;
                }
                
                // Reduce step size if no improvement
                if (!improved) {
                    stepSize *= 0.7;
                    if (stepSize < 0.5) break;
                }
            }
            
            return {
                rgb: labToRgb(currentLab),
                lab: currentLab,
                score: currentScore
            };
        }

        function generateColorCandidates() {
            // Legacy function - kept for compatibility
            // Now we use geometric optimization instead
            const candidates = [];
            const step = 32;
            for (let r = 0; r <= 255; r += step) {
                for (let g = 0; g <= 255; g += step) {
                    for (let b = 0; b <= 255; b += step) {
                        const rgb = [r, g, b];
                        candidates.push({ rgb: rgb, lab: rgbToLab(rgb) });
                    }
                }
            }
            return candidates;
        }

        // --- Intelligent Geometric Optimization with Colorblind Weighting ---

        function optimizeTeam(basePalette, targetSize, lockExisting) {
            console.log(`optimizeTeam called: lockExisting=${lockExisting}, basePalette=${basePalette.length}, targetSize=${targetSize}`);
            
            let fixedColors = [];
            let needed = 0;

            if (lockExisting) {
                // LOCKED: Iterative greedy - add colors one at a time
                console.log('Using ITERATIVE GREEDY mode');
                fixedColors = [...basePalette];
                needed = targetSize - fixedColors.length;
                
                if (needed <= 0) return [];

                const result = [];
                const currentPalette = [...fixedColors];

                for (let i = 0; i < needed; i++) {
                    console.log(`Finding optimal color ${i + 1}/${needed}...`);
                    
                    const coarseSample = findOptimalColorGeometric(currentPalette);
                    if (!coarseSample) {
                        console.warn('Could not find valid color in gamut');
                        break;
                    }
                    
                    const refined = findOptimalColorRefined(coarseSample, currentPalette);
                    
                    const newColor = {
                        rgb: refined.rgb,
                        name: rgbToTNIL(refined.rgb, true),
                        isNew: true,
                        score: refined.score
                    };
                    
                    result.push(newColor);
                    currentPalette.push(newColor);
                    
                    console.log(`Added color ${i + 1}: ${rgbToHex(refined.rgb)} (score: ${refined.score.toFixed(2)})`);
                }

                return result;
            } else {
                // PLANNING MODE: Global optimization - always recalculate from first 6
                const first6 = [
                    { name: 'Cyan', hex: '#00FFFF', rgb: [0, 255, 255] },
                    { name: 'Magenta', hex: '#FF00FF', rgb: [255, 0, 255] },
                    { name: 'Lime', hex: '#00FF00', rgb: [0, 255, 0] },
                    { name: 'Gold', hex: '#FFD700', rgb: [255, 215, 0] },
                    { name: 'Blue', hex: '#0000FF', rgb: [0, 0, 255] },
                    { name: 'Red', hex: '#FF0000', rgb: [255, 0, 0] }
                ];
                
                fixedColors = first6;
                needed = targetSize - 6;
                
                if (needed <= 0) return [];
                
                console.log(`Planning mode: Global optimization for ${needed} additional colors...`);
                return optimizeTeamGlobal(fixedColors, needed);
            }
        }

        // Global optimization: find all colors at once to maximize minimum pairwise distance
        // DETERMINISTIC - no randomness, always produces same result
        function optimizeTeamGlobal(fixedColors, count) {
            const weights = getWeights();
            const uiConstraints = getUIConstraints();
            const minDelta = parseFloat(document.getElementById('minDelta').value) || 20;
            
            // Generate candidate pool
            const candidates = [];
            const step = 12;
            for (let L = 25; L <= 85; L += step) {
                for (let a = -100; a <= 100; a += step) {
                    for (let b = -100; b <= 100; b += step) {
                        const rgb = labToRgb([L, a, b]);
                        if (isRgbInGamut(rgb)) {
                            candidates.push({ rgb, lab: [L, a, b] });
                        }
                    }
                }
            }
            
            console.log(`Candidate pool: ${candidates.length} colors`);
            
            // Deterministic greedy: build set one color at a time, always picking best
            const selectedSet = [];
            const currentPalette = [...fixedColors.map(c => ({ rgb: c.rgb }))];
            
            for (let i = 0; i < count; i++) {
                let bestCandidate = null;
                let bestScore = -Infinity;
                
                // Try each remaining candidate
                for (let candidate of candidates) {
                    // Skip if already selected
                    if (selectedSet.some(s => deltaE(s.lab, candidate.lab) < 1)) continue;
                    
                    // Skip if too close to fixed colors
                    let tooClose = false;
                    for (let fixed of fixedColors) {
                        if (deltaE(candidate.lab, rgbToLab(fixed.rgb)) < minDelta * 0.8) {
                            tooClose = true;
                            break;
                        }
                    }
                    if (tooClose) continue;
                    
                    // Check UI constraints and problematic colors
                    let violatesConstraints = false;
                    for (let ui of uiConstraints.colors) {
                        const dist = deltaE(candidate.lab, rgbToLab(ui.rgb));
                        const threshold = ui.minDist || uiConstraints.minDist;
                        if (dist < threshold) {
                            violatesConstraints = true;
                            break;
                        }
                    }
                    if (violatesConstraints) continue;
                    
                    // Test adding this candidate to current set
                    const testSet = [...currentPalette, candidate, ...selectedSet];
                    const score = scoreColorSet(testSet, weights, minDelta);
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestCandidate = candidate;
                    }
                }
                
                if (bestCandidate) {
                    selectedSet.push(bestCandidate);
                    console.log(`Selected color ${i + 1}/${count}: ${rgbToHex(bestCandidate.rgb)} (score: ${bestScore.toFixed(2)})`);
                } else {
                    console.warn(`Could not find color ${i + 1}/${count}`);
                    break;
                }
            }
            
            console.log(`Global optimization complete. Final score: ${scoreColorSet([...currentPalette, ...selectedSet], weights, minDelta).toFixed(2)}`);
            
            return selectedSet.map((c, i) => ({
                rgb: c.rgb,
                name: rgbToTNIL(c.rgb, true),
                isNew: true
            }));
        }

        // Score a complete color set based on minimum pairwise distances
        function scoreColorSet(colorSet, weights, minDelta) {
            let minPairwiseScore = Infinity;
            
            // Check all pairs
            for (let i = 0; i < colorSet.length; i++) {
                for (let j = i + 1; j < colorSet.length; j++) {
                    let pairScore = 0;
                    
                    // Calculate weighted distance across colorblind modes
                    const modes = ['normal', 'deuteranopia', 'protanopia', 'tritanopia'];
                    for (let mode of modes) {
                        const w = weights[mode];
                        if (w <= 0) continue;
                        
                        const rgb1 = simulateColorBlindness(colorSet[i].rgb, mode);
                        const rgb2 = simulateColorBlindness(colorSet[j].rgb, mode);
                        const lab1 = rgbToLab(rgb1);
                        const lab2 = rgbToLab(rgb2);
                        const dist = deltaE(lab1, lab2);
                        
                        let modeScore = dist * w;
                        if (dist < minDelta) {
                            modeScore -= (minDelta - dist) * 5 * w; // Heavy penalty
                        }
                        pairScore += modeScore;
                    }
                    
                    minPairwiseScore = Math.min(minPairwiseScore, pairScore);
                }
            }
            
            return minPairwiseScore;
        }

        // --- Visualization ---

        function renderHeatmap() {
            const container = document.getElementById('heatmapContainer');
            container.innerHTML = '';

            let activeColors = [];
            
            // Use pinned candidate if available, otherwise use hovered
            const displayCandidate = pinnedCandidate || hoveredCandidate;
            
            if (gameMode) {
                // GAME MODE: Show actual colors array (no defaultPlan)
                activeColors = [...colors];
                
                if (displayCandidate) {
                    // Add the displayed candidate
                    const tnilName = rgbToTNIL(displayCandidate.rgb, true);
                    activeColors.push({ 
                        name: tnilName, 
                        rgb: displayCandidate.rgb, 
                        hex: rgbToHex(displayCandidate.rgb), 
                        isHovered: true 
                    });
                }
            } else {
                // Unlocked: first 6 colors + re-optimized additions
                activeColors = colors.slice(0, 6).map(c => ({
                    name: c.name,
                    rgb: c.rgb,
                    hex: c.hex
                }));
                
                if (displayCandidate && displayCandidate.futureSteps) {
                    activeColors.push({ 
                        name: rgbToTNIL(displayCandidate.rgb, true), 
                        rgb: displayCandidate.rgb, 
                        hex: rgbToHex(displayCandidate.rgb), 
                        isHovered: true 
                    });
                    activeColors.push(...displayCandidate.futureSteps.map(step => ({
                        name: step.name,
                        rgb: step.rgb,
                        hex: rgbToHex(step.rgb),
                        isNew: true
                    })));
                } else if (defaultPlan && defaultPlan.length > 0) {
                    activeColors.push(...defaultPlan.map(step => ({
                        name: step.name,
                        rgb: step.rgb,
                        hex: rgbToHex(step.rgb),
                        isNew: true
                    })));
                }
            }

            const n = activeColors.length;
            const panel = document.createElement('div');
            panel.className = 'heatmap-panel';
            const grid = document.createElement('div');
            grid.className = 'heatmap-grid';
            grid.style.gridTemplateColumns = `60px repeat(${n}, 1fr)`;

            grid.appendChild(document.createElement('div'));
            activeColors.forEach(color => {
                const label = document.createElement('div');
                label.className = 'heatmap-label';
                label.textContent = color.name.substring(0, 3);
                label.style.color = color.hex;
                if (color.isHovered) label.style.fontWeight = 'bold';
                grid.appendChild(label);
            });

            activeColors.forEach((rowColor, i) => {
                const rowLabel = document.createElement('div');
                rowLabel.className = 'heatmap-label';
                rowLabel.textContent = rowColor.name.substring(0, 3);
                rowLabel.style.color = rowColor.hex;
                if (rowColor.isHovered) rowLabel.style.fontWeight = 'bold';
                grid.appendChild(rowLabel);
                activeColors.forEach((colColor, j) => {
                    const cell = document.createElement('div');
                    cell.className = 'heatmap-cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    if (i === j) {
                        // DIAGONAL: Show colorblind simulation
                        const cbRgb = simulateColorBlindness(rowColor.rgb, currentMode);
                        cell.style.background = rgbToHex(cbRgb);
                        if (rowColor.isHovered) cell.style.border = '2px solid #0ff';
                    } else {
                        const rgb1 = simulateColorBlindness(rowColor.rgb, currentMode);
                        const rgb2 = simulateColorBlindness(colColor.rgb, currentMode);
                        const lab1 = rgbToLab(rgb1);
                        const lab2 = rgbToLab(rgb2);
                        const diff = deltaE(lab1, lab2);
                        if (j > i) {
                            // Upper right: visual gradient
                            cell.style.background = `linear-gradient(135deg, ${rgbToHex(rgb1)} 50%, ${rgbToHex(rgb2)} 50%)`;
                            cell.style.color = diff < 15 ? '#ff4444' : (diff > 40 ? '#44ff44' : '#ffff44');
                            cell.style.textShadow = '0 0 2px #000';
                            cell.textContent = diff.toFixed(0);
                        } else {
                            // Lower left: numeric with color-coded background
                            const hue = Math.max(0, Math.min(120, diff * 1.5));
                            cell.style.background = `hsl(${hue}, 80%, 40%)`;
                            cell.style.color = '#fff';
                            cell.textContent = diff.toFixed(0);
                        }
                        if (rowColor.isHovered || colColor.isHovered) {
                            // Use the visible colorblind color for border
                            const borderRgb = rowColor.isHovered ? rgb1 : rgb2;
                            cell.style.border = `2px solid ${rgbToHex(borderRgb)}`;
                        }
                    }
                    cell.onmouseover = () => highlightMirror(i, j, true, cell, activeColors);
                    cell.onmouseout = () => highlightMirror(i, j, false, cell, activeColors);
                    grid.appendChild(cell);
                });
            });
            panel.appendChild(grid);
            container.appendChild(panel);
        }

        function highlightMirror(row, col, active, sourceCell, activeColors) {
            const cells = document.querySelectorAll('.heatmap-cell');
            const n = Math.sqrt(cells.length);
            const mirrorIdx = col * n + row;
            const currentIdx = row * n + col;
            
            if (active) {
                // Get the colorblind-simulated colors for proper border
                const rowColor = activeColors[row];
                const colColor = activeColors[col];
                const rgb1 = simulateColorBlindness(rowColor.rgb, currentMode);
                const rgb2 = simulateColorBlindness(colColor.rgb, currentMode);
                
                // Use the rating color from upper triangle, or calculate it
                let ratingColor = row < col ? sourceCell.style.color : cells[mirrorIdx].style.color;
                
                // Current cell
                cells[currentIdx].style.borderColor = rgbToHex(rgb1);
                cells[currentIdx].style.borderWidth = '3px';
                cells[currentIdx].style.borderStyle = 'solid';
                cells[currentIdx].style.zIndex = '10';
                cells[currentIdx].style.transform = 'scale(1.05)';
                
                // Mirror cell
                cells[mirrorIdx].style.borderColor = rgbToHex(rgb2);
                cells[mirrorIdx].style.borderWidth = '3px';
                cells[mirrorIdx].style.borderStyle = 'solid';
                cells[mirrorIdx].style.zIndex = '10';
                cells[mirrorIdx].style.transform = 'scale(1.05)';
            } else {
                cells[currentIdx].style.border = 'none';
                cells[currentIdx].style.zIndex = 'auto';
                cells[currentIdx].style.transform = 'scale(1)';
                cells[mirrorIdx].style.border = 'none';
                cells[mirrorIdx].style.zIndex = 'auto';
                cells[mirrorIdx].style.transform = 'scale(1)';
            }
        }

        // --- Calculation Breakdown Display ---

        function showCalculationBreakdown(rgb, event) {
            const breakdown = calculateDetailedScore(rgb, colors, true);
            const panel = document.getElementById('calculationBreakdown');
            const content = document.getElementById('breakdownContent');
            
            let html = `<div style="color:#fff; margin-bottom: 6px;">
                <span style="color:#0ff">Candidate:</span> ${breakdown.hex} 
                <span style="color:#888">| LAB(${breakdown.lab[0].toFixed(1)}, ${breakdown.lab[1].toFixed(1)}, ${breakdown.lab[2].toFixed(1)})</span>
            </div>`;
            
            // UI Penalties
            if (breakdown.uiPenalties.length > 0) {
                html += `<div style="color:#f88; margin-bottom: 4px; font-size: 9px;">‚ö† UI Penalties:</div>`;
                breakdown.uiPenalties.forEach(p => {
                    html += `<div style="color:#f88; margin-left: 8px; font-size: 8px;">
                        ‚Ä¢ ${p.name}: ŒîE=${p.distance.toFixed(1)} ‚Üí <span style="color:#f44">-${p.penalty.toFixed(1)}</span>
                    </div>`;
                });
            }
            
            // Mode Scores (compact)
            html += `<div style="color:#0ff; margin: 6px 0 4px 0; font-size: 9px;">üìä Weighted Distances:</div>`;
            breakdown.modeScores.forEach(m => {
                const modeColor = m.mode === 'normal' ? '#0f0' : 
                                 m.mode === 'deuteranopia' ? '#ff0' :
                                 m.mode === 'protanopia' ? '#f80' : '#88f';
                html += `<div style="margin-left: 8px; margin-bottom: 3px; font-size: 8px;">
                    <span style="color:${modeColor}; font-weight:bold;">${m.mode.substr(0,4)}:</span>
                    <span style="color:#888"> ${(m.weight * 100).toFixed(1)}%</span>
                    <span style="color:#aaa;"> √ó ${m.minDistance.toFixed(1)}</span>
                    ${m.penalty > 0 ? `<span style="color:#f88;"> -${m.penalty.toFixed(1)}</span>` : ''}
                    <span style="color:#0ff;"> = ${m.finalScore.toFixed(2)}</span>
                </div>`;
            });
            
            // TNIL Proportional Bonus
            if (breakdown.tnilBonus !== undefined) {
                const count = breakdown.tnilCount || 0;
                const freq = breakdown.tnilFrequency || 0;
                const freqPercent = (freq * 100).toFixed(1);
                const fullTnilName = tnilFullNames[breakdown.tnilName] || breakdown.tnilName.replace('-', '');
                html += `<div style="color:#0f0; margin: 6px 0 4px 0; font-size: 9px;">
                    üìä TNIL Name: <span style="color:#0ff; font-weight:bold;">"${fullTnilName}"</span><br>
                    <span style="margin-left: 12px; color:#888;">Frequency: ${count} times (${freqPercent}%)</span><br>
                    <span style="margin-left: 12px; color:#0f0;">Proportional Bonus: +${breakdown.tnilBonus.toFixed(1)}</span>
                </div>`;
            }
            
            // Total
            html += `<div style="border-top: 1px solid #333; margin-top: 6px; padding-top: 4px; color:#0ff; font-size: 10px; font-weight: bold;">
                TOTAL = ${breakdown.total.toFixed(2)}
            </div>`;
            
            content.innerHTML = html;
            
            // Position tooltip near mouse
            const x = event ? event.clientX : window.innerWidth / 2;
            const y = event ? event.clientY : window.innerHeight / 2;
            
            panel.style.left = (x + 15) + 'px';
            panel.style.top = (y + 15) + 'px';
            panel.style.display = 'block';
        }

        function hideCalculationBreakdown() {
            document.getElementById('calculationBreakdown').style.display = 'none';
        }

        // --- Candidate Recommender ---

        function renderRecommendations(forceCalculate = false) {
            const teamSize = parseInt(document.getElementById('teamSize').value);
            const grid = document.getElementById('recommendationsGrid');
            
            // Don't auto-calculate - show button instead
            if (!forceCalculate) {
                grid.innerHTML = `
                    <div style="grid-column:1/-1;text-align:center;padding:20px">
                        <button class="btn primary" onclick="renderRecommendations(true)" style="font-size: 12px; padding: 8px 20px;">
                            üî¨ Calculate Candidates (Old Test)
                        </button>
                        <div style="color:#666;margin-top:10px;font-size:9px;">
                            Click to calculate optimal color candidates<br>
                            (This may take a moment - uses complex fractal system)
                        </div>
                    </div>
                `;
                return;
            }
            
            if (gameMode) {
                // GAME MODE: Show the optimal next color to add
                grid.innerHTML = '<div style="color:#888;grid-column:1/-1;text-align:center;padding:20px">Computing optimal next color...</div>';
            } else {
                // PLANNING MODE: Show the defaultPlan colors as candidates
                grid.innerHTML = '<div style="color:#888;grid-column:1/-1;text-align:center;padding:20px">Showing globally optimized palette...</div>';
            }

            setTimeout(() => {
                console.log('Rendering candidates...');
                console.log('Existing colors:', colors.map(c => `${c.name}: ${rgbToHex(c.rgb)}`));
                
                // Find the #1 optimal candidate using geometric optimization
                const optimalCandidate = findOptimalColorGeometric(colors);
                
                if (!optimalCandidate) {
                    grid.innerHTML = '<div style="color:#f88;grid-column:1/-1;text-align:center;padding:20px">Could not find valid candidates in gamut</div>';
                    return;
                }
                
                console.log('Optimal coarse candidate:', rgbToHex(optimalCandidate.rgb), 'LAB:', optimalCandidate.lab);
                
                // Refine it
                const refined = findOptimalColorRefined(optimalCandidate, colors);
                
                console.log('Refined optimal:', rgbToHex(refined.rgb), 'Score:', refined.score.toFixed(2));
                
                // Check distances to existing colors
                colors.forEach(c => {
                    const dist = deltaE(refined.lab, rgbToLab(c.rgb));
                    console.log(`  Distance to ${c.name}: ŒîE = ${dist.toFixed(1)}`);
                });
                
                if (gameMode) {
                    // GAME MODE: Only show the #1 optimal next color
                    // Don't calculate future steps - too expensive and not needed
                    const uniqueCandidates = [{
                        rgb: refined.rgb,
                        lab: refined.lab,
                        score: refined.score,
                        rank: 1,
                        name: rgbToTNIL(refined.rgb, true),
                        futureSteps: [] // Don't calculate in game mode
                    }];
                    
                    console.log(`Showing optimal next color: ${rgbToHex(refined.rgb)}`);
                    renderFractalGrid(uniqueCandidates);
                } else {
                    // PLANNING MODE: Generate variations and calculate future steps
                    const candidates = [refined];
                    const variations = 19; // Total 20 candidates
                    
                    // Create variations by exploring different regions of LAB space
                    const explorationPoints = [];
                    
                    // Add the refined optimal
                    explorationPoints.push(refined);
                    
                    // Explore different L levels (lightness)
                    for (let L = 30; L <= 80; L += 10) {
                        // Explore different hue angles in a*b* plane
                        for (let angle = 0; angle < 360; angle += 30) {
                            const radius = 60; // Fixed radius in a*b* plane
                            const a = Math.cos(angle * Math.PI / 180) * radius;
                            const b = Math.sin(angle * Math.PI / 180) * radius;
                            
                            const testLab = [L, a, b];
                            const testRgb = labToRgb(testLab);
                            
                            if (isRgbInGamut(testRgb)) {
                                const testScore = calculateDetailedScore(testRgb, colors);
                                
                                // Only add if score is positive (not violating constraints)
                                if (testScore > 0) {
                                    explorationPoints.push({
                                        rgb: testRgb,
                                        lab: testLab,
                                        score: testScore
                                    });
                                }
                            }
                        }
                    }
                    
                    // Sort by score and take top candidates
                    explorationPoints.sort((a, b) => b.score - a.score);
                    candidates.push(...explorationPoints.slice(0, variations));
                    
                    // Sort by score
                    candidates.sort((a, b) => b.score - a.score);
                    
                    // Remove duplicates
                    const uniqueCandidates = [];
                    for (let cand of candidates) {
                        let isDuplicate = false;
                        
                        for (let existing of colors) {
                            if (deltaE(cand.lab, rgbToLab(existing.rgb)) < 5) {
                                isDuplicate = true;
                                break;
                            }
                        }
                        
                        if (!isDuplicate) {
                            for (let unique of uniqueCandidates) {
                                if (deltaE(cand.lab, unique.lab) < 15) {
                                    isDuplicate = true;
                                    break;
                                }
                            }
                        }
                        
                        if (!isDuplicate) {
                            uniqueCandidates.push(cand);
                        }
                        
                        if (uniqueCandidates.length >= 20) break;
                    }

                    // Calculate future steps for each candidate (planning mode only)
                    uniqueCandidates.forEach((g, idx) => {
                        // Unlocked: this candidate is part of a globally optimized set
                        const fixedWithCandidate = [...colors.slice(0, 6), { rgb: g.rgb, name: 'Candidate' }];
                        const remaining = teamSize - fixedWithCandidate.length;
                        if (remaining > 0) {
                            g.futureSteps = optimizeTeamGlobal(fixedWithCandidate, remaining);
                        } else {
                            g.futureSteps = [];
                        }
                        g.rank = idx + 1;
                    });

                    console.log(`Found ${uniqueCandidates.length} optimal candidates`);
                    renderFractalGrid(uniqueCandidates);
                }
            }, 50);
        }

        function renderFractalGrid(items) {
            const grid = document.getElementById('recommendationsGrid');
            grid.innerHTML = '';
            
            items.forEach((item, idx) => {
                const card = document.createElement('div');
                card.className = 'recommendation-card';
                
                // Highlight the #1 best option
                if (idx === 0) {
                    card.style.border = '2px solid #0ff';
                    card.style.background = '#1a2a2a';
                }
                
                card.onclick = () => {
                    // Toggle pin: if already pinned, unpin; otherwise pin this one
                    if (pinnedCandidate === item) {
                        pinnedCandidate = null;
                        card.style.boxShadow = 'none';
                    } else {
                        pinnedCandidate = item;
                        // Remove highlight from all cards
                        document.querySelectorAll('.recommendation-card').forEach(c => {
                            c.style.boxShadow = 'none';
                        });
                        // Highlight this card
                        card.style.boxShadow = '0 0 10px #0ff';
                    }
                    renderColorSpace(); 
                    renderHeatmap();
                    renderSpectrum();
                };
                
                card.onmouseover = (e) => {
                    // Only update hover if nothing is pinned
                    if (!pinnedCandidate) {
                        hoveredCandidate = item;
                        renderColorSpace(); 
                        renderHeatmap();
                        renderSpectrum();
                    }
                    showCalculationBreakdown(item.rgb, e);
                };
                card.onmousemove = (e) => {
                    const panel = document.getElementById('calculationBreakdown');
                    panel.style.left = (e.clientX + 15) + 'px';
                    panel.style.top = (e.clientY + 15) + 'px';
                };
                card.onmouseout = () => {
                    // Only clear hover if nothing is pinned
                    if (!pinnedCandidate) {
                        hoveredCandidate = null; 
                        renderColorSpace(); 
                        renderHeatmap();
                        renderSpectrum();
                    }
                    hideCalculationBreakdown();
                };

                // Rank badge
                const rank = document.createElement('div');
                rank.style.position = 'absolute';
                rank.style.top = '4px';
                rank.style.left = '4px';
                rank.style.background = idx === 0 ? '#0ff' : '#333';
                rank.style.color = idx === 0 ? '#000' : '#888';
                rank.style.padding = '2px 6px';
                rank.style.fontSize = '8px';
                rank.style.fontWeight = 'bold';
                rank.style.borderRadius = '2px';
                rank.textContent = `#${idx + 1}`;

                const preview = document.createElement('div');
                preview.className = 'rec-color-preview';
                preview.style.background = `rgb(${item.rgb[0]}, ${item.rgb[1]}, ${item.rgb[2]})`;
                preview.style.position = 'relative';
                preview.appendChild(rank);
                
                if (item.futureSteps && item.futureSteps.length > 0) {
                    const dots = document.createElement('div');
                    dots.className = 'preview-dots';
                    item.futureSteps.forEach(step => {
                        const d = document.createElement('div');
                        d.className = 'preview-dot';
                        d.style.background = `rgb(${step.rgb[0]}, ${step.rgb[1]}, ${step.rgb[2]})`;
                        dots.appendChild(d);
                    });
                    preview.appendChild(dots);
                }
                card.appendChild(preview);

                const hex = document.createElement('div');
                hex.style.fontSize = '9px';
                hex.style.color = idx === 0 ? '#0ff' : '#888';
                hex.style.fontWeight = idx === 0 ? 'bold' : 'normal';
                hex.textContent = rgbToHex(item.rgb);
                card.appendChild(hex);

                const score = document.createElement('div');
                score.className = 'rec-score';
                score.innerHTML = `<span>Score:</span><span class="rec-score-value" style="color:${idx === 0 ? '#0ff' : '#888'}">${item.score.toFixed(1)}</span>`;
                card.appendChild(score);
                
                // Show minimum distances to existing colors
                if (idx === 0) {
                    const distances = document.createElement('div');
                    distances.style.fontSize = '8px';
                    distances.style.color = '#666';
                    distances.style.marginTop = '3px';
                    let minDist = Infinity;
                    let closestColor = '';
                    colors.forEach(c => {
                        const dist = deltaE(rgbToLab(item.rgb), rgbToLab(c.rgb));
                        if (dist < minDist) {
                            minDist = dist;
                            closestColor = c.name;
                        }
                    });
                    distances.textContent = `Closest: ${closestColor} (ŒîE=${minDist.toFixed(1)})`;
                    card.appendChild(distances);
                }

                // TNIL name display
                const tnilName = document.createElement('div');
                tnilName.style.fontSize = '10px';
                tnilName.style.color = idx === 0 ? '#0ff' : '#888';
                tnilName.style.fontWeight = 'bold';
                tnilName.style.marginTop = '3px';
                tnilName.style.fontFamily = 'monospace';
                tnilName.textContent = rgbToTNIL(item.rgb, true);
                card.appendChild(tnilName);

                const btnAdd = document.createElement('button');
                btnAdd.className = idx === 0 ? 'btn primary' : 'btn';
                btnAdd.innerHTML = idx === 0 ? '‚òÖ Add Best' : '+ Add';
                btnAdd.style.width = '100%';
                btnAdd.style.marginTop = '5px';
                btnAdd.style.fontSize = '9px';
                btnAdd.onclick = (e) => { 
                    e.stopPropagation(); 
                    const newColor = { 
                        name: rgbToTNIL(item.rgb, true), 
                        hex: rgbToHex(item.rgb), 
                        rgb: item.rgb 
                    };
                    colors.push(newColor);
                    updateAll(); 
                };
                card.appendChild(btnAdd);
                grid.appendChild(card);
            });
        }

        // --- Color Space & Gamut ---

        function renderColorSpace() {
            const container = document.getElementById('colorspaceContainer');
            container.innerHTML = '';
            const modes = ['normal', currentMode];
            const titles = ['Normal Vision Color Space', `${currentMode.charAt(0).toUpperCase() + currentMode.slice(1)} Color Space`];

            modes.forEach((mode, idx) => {
                const panel = document.createElement('div');
                panel.className = 'colorspace-panel';
                panel.appendChild(document.createElement('div')).textContent = titles[idx];
                const canvas = document.createElement('canvas');
                canvas.className = 'colorspace-canvas';
                canvas.width = 600;
                canvas.height = 400;
                panel.appendChild(canvas);
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 600, 400);

                let allColors = [];
                let baseColors = [];
                
                // Use pinned candidate if available, otherwise use hovered
                const displayCandidate = pinnedCandidate || hoveredCandidate;
                
                if (gameMode) {
                    // GAME MODE: ONLY show actual colors array (same as heatmap and spectrum)
                    baseColors = [...colors];
                    allColors = [...colors];
                    
                    // Only show hovered candidate if hovering
                    if (displayCandidate) {
                        allColors.push({ ...displayCandidate, isNew: true, name: 'Candidate' });
                    }
                } else {
                    // Unlocked: first 6 colors + re-optimized additions
                    baseColors = colors.slice(0, 6);
                    allColors = [...baseColors];
                    
                    if (displayCandidate && displayCandidate.futureSteps) {
                        allColors.push({ ...displayCandidate, isNew: true, name: 'Candidate' });
                        allColors.push(...displayCandidate.futureSteps.map(s => ({ ...s, isNew: true })));
                    } else if (defaultPlan.length > 0) {
                        allColors.push(...defaultPlan);
                    }
                }

                drawVoronoiMap(ctx, mode, allColors);

                // Axes
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(300, 0); ctx.lineTo(300, 400);
                ctx.moveTo(0, 200); ctx.lineTo(600, 200);
                ctx.stroke();

                // Plot Dots - show base colors
                baseColors.forEach(c => plotDot(ctx, c.rgb, c.name, mode, true));
                
                if (displayCandidate) {
                    plotDot(ctx, displayCandidate.rgb, "?", mode, false, true);
                    if (displayCandidate.futureSteps) {
                        displayCandidate.futureSteps.forEach((c, i) => plotDot(ctx, c.rgb, `${i+1}`, mode, false, false, true));
                    }
                } else if (defaultPlan.length > 0) {
                    defaultPlan.forEach((c, i) => plotDot(ctx, c.rgb, `${i+1}`, mode, false, false, true));
                }

                // Draw ALL TNIL root combinations on the color space
                ctx.font = '7px monospace';
                
                // Plot all 24 chromatic TNIL roots (8 roots √ó 3 stems = 24 combinations)
                colorStems.forEach((stem, idx) => {
                    const hue = (idx * 15) % 360; // Each stem covers 15¬∞ on color wheel
                    const saturation = 0.85;
                    const lightness = 0.6;
                    
                    // Convert HSL to RGB using proper formula
                    const h = hue / 60;
                    const c = (1 - Math.abs(2 * lightness - 1)) * saturation;
                    const x_val = c * (1 - Math.abs(h % 2 - 1));
                    const m = lightness - c / 2;
                    
                    let r, g, b;
                    if (h < 1) { r = c; g = x_val; b = 0; }
                    else if (h < 2) { r = x_val; g = c; b = 0; }
                    else if (h < 3) { r = 0; g = c; b = x_val; }
                    else if (h < 4) { r = 0; g = x_val; b = c; }
                    else if (h < 5) { r = x_val; g = 0; b = c; }
                    else { r = c; g = 0; b = x_val; }
                    
                    const rgb = [(r + m) * 255, (g + m) * 255, (b + m) * 255];
                    const simRgb = simulateColorBlindness(rgb, mode);
                    const lab = rgbToLab(simRgb);
                    const px = 300 + lab[1] * 2;
                    const py = 200 - lab[2] * 2;
                    
                    // Draw small dot
                    ctx.fillStyle = `rgb(${simRgb[0]}, ${simRgb[1]}, ${simRgb[2]})`;
                    ctx.beginPath();
                    ctx.arc(px, py, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw label
                    ctx.fillStyle = '#555';
                    ctx.fillText(stem.replace('-', ''), px + 4, py + 2);
                });
                
                // Plot grayscale TNIL roots (5 combinations)
                grayscale.forEach((gray, idx) => {
                    const lightness = idx / 4.999; // 0 to 1
                    const grayVal = lightness * 255;
                    const rgb = [grayVal, grayVal, grayVal];
                    const simRgb = simulateColorBlindness(rgb, mode);
                    const lab = rgbToLab(simRgb);
                    const px = 300 + lab[1] * 2;
                    const py = 200 - lab[2] * 2;
                    
                    // Draw small square
                    ctx.fillStyle = `rgb(${simRgb[0]}, ${simRgb[1]}, ${simRgb[2]})`;
                    ctx.fillRect(px - 2, py - 2, 4, 4);
                    ctx.strokeStyle = '#555';
                    ctx.strokeRect(px - 2, py - 2, 4, 4);
                    
                    // Draw label
                    ctx.fillStyle = '#555';
                    ctx.fillText(gray.replace('-', ''), px + 4, py + 2);
                });

                panel.appendChild(document.createElement('div')).innerHTML =
                    '<div class="info-text">Background: True Gamut (L=60) | Lines: Voronoi | Gray text: All 29 TNIL roots (24 chromatic + 5 grayscale)</div>';
                container.appendChild(panel);
            });
        }

        function drawVoronoiMap(ctx, mode, activeColors) {
            const w = 600;
            const h = 400;
            const imgData = ctx.createImageData(w, h);
            const data = imgData.data;
            const showGamut = document.getElementById('showGamut').checked;

            const points = activeColors.map(c => {
                const sim = simulateColorBlindness(c.rgb, mode);
                const lab = rgbToLab(sim);
                return {
                    l: lab[0], a: lab[1], b: lab[2],
                    rgb: sim,
                    isNew: c.isNew || c.name.startsWith('+') || c.name === 'Candidate'
                };
            });

            function getClosestIdx(a, b) {
                let minDist = Infinity;
                let idx = -1;
                const sliceL = 60;
                for (let i = 0; i < points.length; i++) {
                    const d = (sliceL - points[i].l) ** 2 + (a - points[i].a) ** 2 + (b - points[i].b) ** 2;
                    if (d < minDist) { minDist = d; idx = i; }
                }
                return idx;
            }

            // First pass: fill everything at L=60 slice
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const a = (x - 300) / 2;
                    const b = (200 - y) / 2;
                    const idx = (y * w + x) * 4;

                    // Calculate the color at this Lab position (L=60 slice)
                    const trueRgb = labToRgb([60, a, b]);
                    
                    // Check if in gamut - this creates the curved gamut boundary
                    if (!isRgbInGamut(trueRgb)) {
                        data[idx + 3] = 0; // transparent outside gamut
                        continue;
                    }

                    // Determine which Voronoi region this pixel belongs to
                    if (points.length > 0) {
                        const closestIdx = getClosestIdx(a, b);
                        const owner = points[closestIdx];

                        if (owner.isNew) {
                            // NEW colors: show gradient
                            if (showGamut) {
                                data[idx] = trueRgb[0];
                                data[idx + 1] = trueRgb[1];
                                data[idx + 2] = trueRgb[2];
                                data[idx + 3] = 255;
                            } else {
                                data[idx] = 0;
                                data[idx + 1] = 0;
                                data[idx + 2] = 0;
                                data[idx + 3] = 255;
                            }
                        } else {
                            // EXISTING colors: black fill
                            data[idx] = 0;
                            data[idx + 1] = 0;
                            data[idx + 2] = 0;
                            data[idx + 3] = 255;
                        }
                    } else {
                        // No points: just show gradient
                        if (showGamut) {
                            data[idx] = trueRgb[0];
                            data[idx + 1] = trueRgb[1];
                            data[idx + 2] = trueRgb[2];
                            data[idx + 3] = 255;
                        } else {
                            data[idx] = 0;
                            data[idx + 1] = 0;
                            data[idx + 2] = 0;
                            data[idx + 3] = 255;
                        }
                    }
                }
            }

            // Second pass: draw Voronoi boundaries
            if (points.length > 0) {
                for (let y = 0; y < h - 1; y++) {
                    for (let x = 0; x < w - 1; x++) {
                        const a = (x - 300) / 2;
                        const b = (200 - y) / 2;
                        const idx = (y * w + x) * 4;

                        // Skip if transparent
                        if (data[idx + 3] === 0) continue;

                        const closestIdx = getClosestIdx(a, b);
                        const right = getClosestIdx(a + 0.5, b);
                        const down = getClosestIdx(a, b - 0.5);

                        // Draw boundary if neighbors differ
                        if (closestIdx !== right || closestIdx !== down) {
                            data[idx] = 0;
                            data[idx + 1] = 0;
                            data[idx + 2] = 0;
                            data[idx + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imgData, 0, 0);
            drawGamutWireframe(ctx, mode);
        }

        function drawGamutWireframe(ctx, mode) {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            const corners = [[0, 0, 0], [255, 0, 0], [0, 255, 0], [0, 0, 255], [255, 255, 0], [255, 0, 255], [0, 255, 255], [255, 255, 255]];
            const edges = [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5], [2, 4], [2, 6], [3, 5], [3, 6], [4, 7], [5, 7], [6, 7]];
            ctx.beginPath();
            edges.forEach(edge => {
                const start = corners[edge[0]];
                const end = corners[edge[1]];
                for (let i = 0; i <= 10; i++) {
                    const t = i / 10;
                    const r = start[0] + (end[0] - start[0]) * t;
                    const g = start[1] + (end[1] - start[1]) * t;
                    const b = start[2] + (end[2] - start[2]) * t;
                    const sim = simulateColorBlindness([r, g, b], mode);
                    const lab = rgbToLab(sim);
                    const x = 300 + lab[1] * 2;
                    const y = 200 - lab[2] * 2;
                    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
        }

        function plotDot(ctx, rgb, label, mode, isBase, isStack = false, isPlan = false) {
            const sim = simulateColorBlindness(rgb, mode);
            const lab = rgbToLab(sim);
            const x = 300 + lab[1] * 2;
            const y = 200 - lab[2] * 2;
            ctx.fillStyle = `rgb(${sim[0]}, ${sim[1]}, ${sim[2]})`;
            ctx.beginPath();
            ctx.arc(x, y, isStack || isPlan ? 5 : 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.stroke();
            if (isBase || isStack || isPlan) {
                ctx.fillStyle = '#fff';
                ctx.font = '9px monospace';
                ctx.fillText(label.replace('+', ''), x + 8, y + 3);
                
                // Add L value box below the label
                const lValue = `L${Math.round(lab[0])}`;
                ctx.fillStyle = '#000';
                ctx.fillRect(x + 8, y + 6, 22, 10);
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.strokeRect(x + 8, y + 6, 22, 10);
                ctx.fillStyle = '#888';
                ctx.font = '8px monospace';
                ctx.fillText(lValue, x + 9, y + 14);
            }
        }

        function renderSpectrum() {
            const container = document.getElementById('spectrumContainer');
            container.innerHTML = '';
            const modes = ['normal', 'deuteranopia', 'protanopia', 'tritanopia'];
            const titles = ['Normal', 'Deuteranopia', 'Protanopia', 'Tritanopia'];
            
            let displayColors = [];
            
            // Use pinned candidate if available, otherwise use hovered
            const displayCandidate = pinnedCandidate || hoveredCandidate;
            
            if (gameMode) {
                // GAME MODE: ONLY show the actual colors array (same as heatmap)
                displayColors = [...colors];
                
                // Only show hovered candidate if hovering
                if (displayCandidate) {
                    const tnilName = rgbToTNIL(displayCandidate.rgb, true);
                    displayColors.push({ 
                        name: tnilName, 
                        rgb: displayCandidate.rgb, 
                        isHovered: true 
                    });
                }
            } else {
                // Unlocked: show complete re-optimized palette
                if (displayCandidate && displayCandidate.futureSteps) {
                    displayColors = [
                        { 
                            name: rgbToTNIL(displayCandidate.rgb, true), 
                            rgb: displayCandidate.rgb, 
                            isHovered: true 
                        },
                        ...displayCandidate.futureSteps
                    ];
                } else if (defaultPlan && defaultPlan.length > 0) {
                    displayColors = [...defaultPlan];
                } else {
                    displayColors = [...colors];
                }
            }
            
            modes.forEach((mode, idx) => {
                const panel = document.createElement('div');
                panel.className = 'spectrum-panel';
                panel.innerHTML = `<div class="panel-title">${titles[idx]}</div>`;
                const grid = document.createElement('div');
                grid.className = 'spectrum-grid';
                
                // Calculate grid columns based on number of colors
                const numColors = displayColors.length;
                const cols = Math.ceil(Math.sqrt(numColors));
                grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
                
                displayColors.forEach(color => {
                    const rgb = simulateColorBlindness(color.rgb, mode);
                    const cell = document.createElement('div');
                    cell.className = 'spectrum-cell';
                    cell.style.background = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                    cell.style.color = getTextColor(rgb);
                    cell.textContent = (color.name || "?").substring(0, 3);
                    if (color.isHovered) {
                        cell.style.border = '2px solid #0ff';
                        cell.style.transform = 'scale(1.1)';
                        cell.style.zIndex = '10';
                    } else if (color.isNew) {
                        cell.style.opacity = '0.6';
                        cell.style.border = '1px solid #666';
                    }
                    grid.appendChild(cell);
                });
                panel.appendChild(grid);
                container.appendChild(panel);
            });
        }

        function updateAll() {
            const teamSize = parseInt(document.getElementById('teamSize').value);
            console.log(`updateAll: gameMode=${gameMode}, colors=${colors.length}, teamSize=${teamSize}`);
            
            // Use gameMode to determine optimization strategy
            defaultPlan = optimizeTeam(colors, teamSize, gameMode);
            
            console.log(`defaultPlan calculated: ${defaultPlan.length} colors`);
            if (defaultPlan.length > 0) {
                console.log(`First planned color: ${rgbToHex(defaultPlan[0].rgb)}`);
            }

            renderHeatmap();
            renderSpectrum();
            renderColorSpace();
            renderRecommendations();
        }

        // Game mode controls
        document.getElementById('startGameBtn').addEventListener('click', () => {
            console.log('=== START GAME ===');
            console.log('Locking in current palette...');
            
            // LOCK IN the current colors + defaultPlan into the colors array
            // This preserves the planning mode results
            if (defaultPlan && defaultPlan.length > 0) {
                colors = [
                    ...colors.slice(0, 6), // First 6 preset colors
                    ...defaultPlan.map(c => ({
                        name: c.name || rgbToTNIL(c.rgb), // Ensure name is set
                        hex: rgbToHex(c.rgb),
                        rgb: c.rgb
                    }))
                ];
                console.log(`Locked ${colors.length} colors from planning mode`);
                console.log('Locked TNIL names:', colors.map(c => c.name).join(', '));
            }
            
            gameMode = true;
            document.getElementById('startGameBtn').style.display = 'none';
            document.getElementById('stopGameBtn').style.display = 'inline-block';
            document.getElementById('addTeamColorBtn').disabled = false;
            document.getElementById('teamSize').disabled = true;
            
            // Update visualizations to show locked colors
            renderHeatmap();
            renderSpectrum();
            renderColorSpace();
            renderRecommendations();
        });

        document.getElementById('stopGameBtn').addEventListener('click', () => {
            gameMode = false;
            document.getElementById('startGameBtn').style.display = 'inline-block';
            document.getElementById('stopGameBtn').style.display = 'none';
            document.getElementById('addTeamColorBtn').disabled = true;
            document.getElementById('teamSize').disabled = false;
            // Don't call updateAll() - just switch mode, keep existing colors
            renderRecommendations(); // Only update recommendations
        });

        // Reset button - keeps first 6 colors, optimizes the rest
        document.getElementById('resetGameBtn').addEventListener('click', () => {
            const teamSize = parseInt(document.getElementById('teamSize').value);
            console.log(`Resetting to optimal ${teamSize} colors (keeping first 6)...`);
            
            // Always keep first 6 colors: Cyan, Magenta, Lime, Gold, Blue, Red
            const fixedColors = [
                { name: 'Cyan', hex: '#00FFFF', rgb: [0, 255, 255] },
                { name: 'Magenta', hex: '#FF00FF', rgb: [255, 0, 255] },
                { name: 'Lime', hex: '#00FF00', rgb: [0, 255, 0] },
                { name: 'Gold', hex: '#FFD700', rgb: [255, 215, 0] },
                { name: 'Blue', hex: '#0000FF', rgb: [0, 0, 255] },
                { name: 'Red', hex: '#FF0000', rgb: [255, 0, 0] }
            ];
            
            if (teamSize <= 6) {
                // Just use the first N fixed colors
                colors = fixedColors.slice(0, teamSize);
            } else {
                // Keep first 6, optimize the rest
                const needed = teamSize - 6;
                const optimalAdditions = optimizeTeamGlobal(fixedColors, needed);
                colors = [...fixedColors, ...optimalAdditions.map(c => ({
                    name: c.name,
                    hex: rgbToHex(c.rgb),
                    rgb: c.rgb
                }))];
            }
            
            console.log(`Reset complete: ${colors.length} colors`);
            pinnedCandidate = null;
            updateAll();
        });

        document.getElementById('addTeamColorBtn').addEventListener('click', () => {
            if (gameMode) {
                // Find the optimal next color using geometric optimization
                console.log('=== ADD TEAM COLOR CLICKED ===');
                console.log('Current palette has', colors.length, 'colors:');
                colors.forEach((c, i) => {
                    console.log(`  ${i + 1}. ${c.name}: ${c.hex || rgbToHex(c.rgb)}`);
                });
                
                // Log current constraints
                const weights = getWeights();
                const uiConstraints = getUIConstraints();
                const minDelta = parseFloat(document.getElementById('minDelta').value) || 20;
                const tnilBonus = parseFloat(document.getElementById('tnilUniquenessBonus').value) || 100;
                console.log('Active constraints:');
                console.log('  Weights:', weights);
                console.log('  Min Delta:', minDelta);
                console.log('  UI Constraints:', uiConstraints.colors.length, 'colors');
                console.log('  TNIL Bonus:', tnilBonus);
                
                console.log('Finding optimal next color for current palette...');
                const coarseSample = findOptimalColorGeometric(colors);
                if (!coarseSample) {
                    console.warn('Could not find valid color in gamut');
                    return;
                }
                
                console.log('Coarse sample found:', rgbToHex(coarseSample.rgb));
                
                const refined = findOptimalColorRefined(coarseSample, colors);
                
                console.log('Refined result:', rgbToHex(refined.rgb), 'Score:', refined.score);
                
                // Check TNIL name
                const tnilName = rgbToTNIL(refined.rgb, true);
                const existingNames = colors.map(c => c.name || rgbToTNIL(c.rgb, true));
                console.log('TNIL name:', tnilName, '| Already exists?', existingNames.includes(tnilName));
                
                const optimalColor = {
                    name: rgbToTNIL(refined.rgb, true),
                    hex: rgbToHex(refined.rgb),
                    rgb: refined.rgb
                };
                
                colors.push(optimalColor);
                console.log(`‚úì Added team color: ${optimalColor.name} ${optimalColor.hex}`);
                console.log(`Total colors now: ${colors.length}`);
                
                // Clear pinned candidate
                pinnedCandidate = null;
                hoveredCandidate = null;
                document.querySelectorAll('.recommendation-card').forEach(c => {
                    c.style.boxShadow = 'none';
                });
                
                // ONLY update visualizations - DO NOT recalculate defaultPlan
                // This ensures existing colors are never changed
                renderHeatmap();
                renderSpectrum();
                renderColorSpace();
                renderRecommendations();
            }
        });
        
        // Student manager - live update when values change
        ['studentNormal', 'studentDeut', 'studentProt', 'studentTrit'].forEach(id => {
            document.getElementById(id).addEventListener('input', () => {
                if (!gameMode) {
                    // Only auto-update in planning mode
                    console.log('Student distribution changed, recalculating...');
                    updateAll();
                }
            });
        });

        // UI constraint controls
        ['avoidBlack', 'avoidWhite', 'avoidGrey', 'avoidBlood', 'avoidBrown'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                if (!gameMode) {
                    console.log('Constraints changed, recalculating...');
                    updateAll();
                }
            });
        });
        
        document.getElementById('uiMinDist').addEventListener('change', () => {
            if (!gameMode) {
                console.log('UI min distance changed, recalculating...');
                updateAll();
            }
        });
        
        document.getElementById('problematicMinDist').addEventListener('change', () => {
            if (!gameMode) {
                console.log('Problematic color distance changed, recalculating...');
                updateAll();
            }
        });
        
        document.getElementById('tnilUniquenessBonus').addEventListener('change', () => {
            if (!gameMode) {
                console.log('TNIL uniqueness bonus changed, recalculating...');
                updateAll();
            }
        });

        document.querySelectorAll('.toggle').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.toggle').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMode = btn.dataset.mode;
                updateAll();
            });
        });

        document.getElementById('teamSize').addEventListener('input', (e) => {
            document.getElementById('teamSizeVal').textContent = e.target.value;
            updateAll();
        });

        // Control listeners
        document.getElementById('showGamut').addEventListener('change', () => {
            renderColorSpace();
        });
        document.getElementById('minDelta').addEventListener('change', updateAll);

        // Preset mode switching
        document.getElementById('presetGameTeams').addEventListener('click', () => {
            presetMode = 'gameTeams';
            document.getElementById('presetGameTeams').classList.add('primary');
            document.getElementById('presetPureColor').classList.remove('primary');
            document.getElementById('studentManagerGameTeams').style.display = 'flex';
            document.getElementById('pureColorMode').style.display = 'none';
            document.getElementById('pureColorPreview').style.display = 'none';
            updateAll();
        });

        document.getElementById('presetPureColor').addEventListener('click', () => {
            presetMode = 'pureColor';
            document.getElementById('presetPureColor').classList.add('primary');
            document.getElementById('presetGameTeams').classList.remove('primary');
            document.getElementById('studentManagerGameTeams').style.display = 'none';
            document.getElementById('pureColorMode').style.display = 'flex';
            document.getElementById('pureColorPreview').style.display = 'block';
            generatePureColorPreview();
        });

        // Pure color mode buttons
        ['pureNormal', 'pureDeuteranopia', 'pureProtanopia', 'pureTritanopia'].forEach(id => {
            document.getElementById(id).addEventListener('click', () => {
                // Remove primary from all
                ['pureNormal', 'pureDeuteranopia', 'pureProtanopia', 'pureTritanopia'].forEach(btnId => {
                    document.getElementById(btnId).classList.remove('primary');
                });
                // Add primary to clicked
                document.getElementById(id).classList.add('primary');
                
                // Set status
                pureColorStatus = id.replace('pure', '').toLowerCase();
                generatePureColorPreview();
            });
        });

        // Hue shift bias controls
        document.getElementById('hueShiftBias').addEventListener('change', () => {
            if (!gameMode && presetMode === 'gameTeams') {
                console.log('Hue shift bias changed, recalculating...');
                updateAll();
            }
        });
        
        document.getElementById('hueShiftStrength').addEventListener('change', () => {
            if (!gameMode && presetMode === 'gameTeams') {
                console.log('Hue shift strength changed, recalculating...');
                updateAll();
            }
        });

        // Pure color generation
        function generatePureColorPreview() {
            const grid = document.getElementById('pureColorGrid');
            grid.innerHTML = '<div style="color:#888;grid-column:1/-1;text-align:center;padding:20px">Generating optimal colors...</div>';
            
            setTimeout(() => {
                // Generate optimal colors for the selected colorblind status
                const categories = [
                    { name: 'Primary', count: 3 },
                    { name: 'Secondary', count: 3 },
                    { name: 'Accent', count: 2 },
                    { name: 'Neutral', count: 2 }
                ];
                
                grid.innerHTML = '';
                
                categories.forEach(category => {
                    const categoryDiv = document.createElement('div');
                    categoryDiv.style.gridColumn = '1/-1';
                    categoryDiv.style.marginTop = '15px';
                    categoryDiv.style.marginBottom = '8px';
                    categoryDiv.style.color = '#0ff';
                    categoryDiv.style.fontSize = '11px';
                    categoryDiv.style.fontWeight = 'bold';
                    categoryDiv.textContent = `${category.name} Colors (${category.count})`;
                    grid.appendChild(categoryDiv);
                    
                    // Generate colors for this category
                    const categoryColors = [];
                    for (let i = 0; i < category.count; i++) {
                        const coarse = findOptimalColorGeometric(categoryColors);
                        if (coarse) {
                            const refined = findOptimalColorRefined(coarse, categoryColors);
                            categoryColors.push({ rgb: refined.rgb, name: rgbToTNIL(refined.rgb, true) });
                        }
                    }
                    
                    // Display each color
                    categoryColors.forEach(color => {
                        const card = document.createElement('div');
                        card.style.background = '#1a1a1a';
                        card.style.border = '1px solid #333';
                        card.style.padding = '10px';
                        
                        // Original color
                        const originalDiv = document.createElement('div');
                        originalDiv.style.marginBottom = '8px';
                        originalDiv.innerHTML = `<div style="color:#888;font-size:9px;margin-bottom:3px">Original Color:</div>`;
                        
                        const originalPreview = document.createElement('div');
                        originalPreview.style.width = '100%';
                        originalPreview.style.height = '40px';
                        originalPreview.style.background = rgbToHex(color.rgb);
                        originalPreview.style.border = '1px solid #333';
                        originalDiv.appendChild(originalPreview);
                        
                        const originalHex = document.createElement('div');
                        originalHex.style.fontSize = '10px';
                        originalHex.style.color = '#0ff';
                        originalHex.style.marginTop = '3px';
                        originalHex.style.fontFamily = 'monospace';
                        originalHex.textContent = rgbToHex(color.rgb);
                        originalDiv.appendChild(originalHex);
                        
                        const originalName = document.createElement('div');
                        originalName.style.fontSize = '10px';
                        originalName.style.color = '#888';
                        originalName.style.marginTop = '2px';
                        originalName.textContent = color.name;
                        originalDiv.appendChild(originalName);
                        
                        card.appendChild(originalDiv);
                        
                        // Perceived color (through colorblind filter)
                        const perceivedDiv = document.createElement('div');
                        perceivedDiv.innerHTML = `<div style="color:#888;font-size:9px;margin-bottom:3px">Perceived (${pureColorStatus}):</div>`;
                        
                        const perceivedRgb = simulateColorBlindness(color.rgb, pureColorStatus);
                        const perceivedPreview = document.createElement('div');
                        perceivedPreview.style.width = '100%';
                        perceivedPreview.style.height = '40px';
                        perceivedPreview.style.background = rgbToHex(perceivedRgb);
                        perceivedPreview.style.border = '1px solid #333';
                        perceivedDiv.appendChild(perceivedPreview);
                        
                        const perceivedHex = document.createElement('div');
                        perceivedHex.style.fontSize = '10px';
                        perceivedHex.style.color = '#f80';
                        perceivedHex.style.marginTop = '3px';
                        perceivedHex.style.fontFamily = 'monospace';
                        perceivedHex.textContent = rgbToHex(perceivedRgb);
                        perceivedDiv.appendChild(perceivedHex);
                        
                        const perceivedName = document.createElement('div');
                        perceivedName.style.fontSize = '10px';
                        perceivedName.style.color = '#888';
                        perceivedName.style.marginTop = '2px';
                        perceivedName.textContent = rgbToTNIL(perceivedRgb, true);
                        perceivedDiv.appendChild(perceivedName);
                        
                        card.appendChild(perceivedDiv);
                        
                        // Copy button
                        const copyBtn = document.createElement('button');
                        copyBtn.className = 'btn';
                        copyBtn.style.width = '100%';
                        copyBtn.style.marginTop = '8px';
                        copyBtn.style.fontSize = '9px';
                        copyBtn.textContent = 'Copy Filtered Hex';
                        copyBtn.onclick = () => {
                            navigator.clipboard.writeText(rgbToHex(perceivedRgb));
                            copyBtn.textContent = 'Copied!';
                            setTimeout(() => {
                                copyBtn.textContent = 'Copy Filtered Hex';
                            }, 1000);
                        };
                        card.appendChild(copyBtn);
                        
                        grid.appendChild(card);
                    });
                });
            }, 50);
        }

        updateAll();
    </script>
</body>

</html>
